// Package channeler is a cli generator to generate channeled version of a type.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"golang.org/x/tools/go/loader"
)

var version = "0.0.0"

func main() {

	var help bool
	var h bool
	var ver bool
	var v bool
	var outPkg string
	flag.BoolVar(&help, "help", false, "Show help.")
	flag.BoolVar(&h, "h", false, "Show help.")
	flag.BoolVar(&ver, "version", false, "Show version.")
	flag.BoolVar(&v, "v", false, "Show version.")
	flag.StringVar(&outPkg, "p", "", "Package name of the new code.")

	flag.Parse()

	if ver || v {
		showVer()
		return
	}
	if help || h {
		showHelp()
		return
	}

	if flag.NArg() < 2 {
		panic("wrong usage")
	}
	args := flag.Args()

	if outPkg == "" {
		outPkg = os.Getenv("GOPACKAGE")
	}

	gopath := filepath.Join(os.Getenv("GOPATH"), "src")
	oldp := os.Getenv("OLDPWD")
	pkgToLoad := filepath.Join(oldp[len(gopath)+1:], outPkg)
	dest := os.Stdout

	o := args[0]
	restargs := args[1:]

	prog := getProgram(pkgToLoad).Package(pkgToLoad)
	// astPrintPkg(p)

	foundTypes := findTypes(prog)
	foundMethods := findMethods(prog)
	foundCtors := findCtors(prog, foundTypes)

	if o != "-" {
		f, err := os.Create(o)
		if err != nil {
			panic(err)
		}
		dest = f
		defer func() {
			f.Close()
			exec.Command("go", "fmt", args[0]).Run()
		}()
	}

	fmt.Fprintf(dest, "package %v\n\n", outPkg)
	fmt.Fprintln(dest, `// file generated by`)
	fmt.Fprintln(dest, `// github.com.mh-vbon/channeler`)
	fmt.Fprintln(dest, `// do not edit`)
	fmt.Fprintln(dest, ``)

	for _, todo := range restargs {
		y := strings.Split(todo, ":")
		if len(y) != 2 {
			panic("wrong name " + todo)
		}
		srcName := y[0]
		destName := y[1]

		res := processType(destName, srcName, foundCtors, foundMethods)
		io.Copy(dest, &res)
	}
}

func showVer() {
	fmt.Printf("%v %v\n", "channeler", version)
}

func showHelp() {
	showVer()
	fmt.Println()
	fmt.Println("Usage")
	fmt.Println()
	fmt.Printf("	channeler [-p name] [out] [...types]\n\n")
	fmt.Printf("	out: 	Output destination of the results, use '-' for stdout.\n")
	fmt.Printf("	types:	A list of types such as src:dst.\n")
	fmt.Printf("	-p:			The name of the package output.\n")
	fmt.Println()
}

func getProgram(s string) *loader.Program {

	args := []string{"--", s}

	var conf loader.Config
	_, err := conf.FromArgs(args[1:], false)
	if err != nil {
		fmt.Println(err)
	}
	prog, err := conf.Load()
	if err != nil {
		log.Fatal(err)
	}

	return prog
}

func processType(destName, srcName string, foundCtors map[string]*ast.FuncDecl, foundMethods map[string][]*ast.FuncDecl) bytes.Buffer {

	var b bytes.Buffer
	dest := &b

	fmt.Fprintf(dest, "type %v struct{\n embed %v\n ops chan func()\n}\n", destName, srcName)

	ctorParams := ""
	ctorName := ""
	ctorIsPointer := false
	if x, ok := foundCtors[srcName]; ok {
		ctorParams = methodParams(x)
		ctorIsPointer = methodReturnPointer(x)
		ctorName = "New" + srcName
	}

	fmt.Fprintf(dest, "func New%v(%v) *%v {\n", destName, ctorParams, destName)
	fmt.Fprintf(dest, "	ret := &%v{}\n", destName)
	if ctorName != "" {
		fmt.Fprintf(dest, "	embed := %v(%v)\n", ctorName, ctorParams)
		if ctorIsPointer {
			fmt.Fprintf(dest, "	ret.%v = *embed\n", srcName)
		} else {
			fmt.Fprintf(dest, "	ret.%v = embed\n", srcName)
		}
	}
	fmt.Fprintf(dest, "	go ret.loop()\n")
	fmt.Fprintf(dest, "	return ret\n")
	fmt.Fprintf(dest, "}\n")
	fmt.Fprintf(dest, "func (t *%v) loop(){\n", destName)
	fmt.Fprintf(dest, "	for{\n")
	fmt.Fprintf(dest, "		select{\n")
	fmt.Fprintf(dest, "		case op:=<-%v.ops:\n", "t")
	fmt.Fprintf(dest, "			op()\n")
	fmt.Fprintf(dest, "		}\n")
	fmt.Fprintf(dest, "	}\n")
	fmt.Fprintf(dest, "}\n")
	for _, m := range foundMethods[srcName] {
		paramNames := methodParamNames(m)
		varExpr := ""
		assignExpr := ""
		callExpr := fmt.Sprintf("%v.embed.%v(%v)", receiverName(m), methodName(m), paramNames)
		returnExpr := ""
		methodReturnTypes := methodReturnTypes(m)
		if len(methodReturnTypes) > 0 {
			retVars := methodReturnVars(m)
			varExpr = fmt.Sprintf("var ")
			for i, r := range retVars {
				varExpr += r + " " + methodReturnTypes[i] + ", "
			}
			varExpr = varExpr[:len(varExpr)-2]
			assignExpr = fmt.Sprintf("%v = ", strings.Join(retVars, ", "))
			returnExpr = fmt.Sprintf("return %v", strings.Join(retVars, ", "))
		}
		sExpr := fmt.Sprintf(`
	%v
	t.ops<-func() {%v%v}
	%v
`, varExpr, assignExpr, callExpr, returnExpr)
		sExpr = fmt.Sprintf(`func(){%v}`, sExpr)
		expr, err := parser.ParseExpr(sExpr)
		if err != nil {
			panic(err)
		}
		setReceiverTypeName(m, destName)
		setReceiverPointer(m, true)
		m.Body = expr.(*ast.FuncLit).Body
		fmt.Fprintf(dest, "%v\n", astPrint(m))
	}

	return b
}

func findTypes(p *loader.PackageInfo) []string {
	foundTypes := []string{}
	for _, file := range p.Files {
		ast.Inspect(file, func(n ast.Node) bool {
			switch x := n.(type) {
			case *ast.TypeSpec:
				if _, ok := x.Type.(*ast.StructType); ok {
					foundTypes = append(foundTypes, x.Name.Name)
				}
			}
			return true
		})
	}
	return foundTypes
}

func findMethods(p *loader.PackageInfo) map[string][]*ast.FuncDecl {
	foundMethods := map[string][]*ast.FuncDecl{}
	for _, file := range p.Files {
		ast.Inspect(file, func(n ast.Node) bool {
			switch x := n.(type) {
			case *ast.FuncDecl:
				if x.Recv != nil {
					aboutType := receiverType(x)
					if aboutType != "" {
						if _, ok := foundMethods[aboutType]; !ok {
							foundMethods[aboutType] = []*ast.FuncDecl{}
						}
						foundMethods[aboutType] = append(foundMethods[aboutType], x)
					}
				}
			}
			return true
		})
	}
	return foundMethods
}

func findCtors(p *loader.PackageInfo, aboutTypes []string) map[string]*ast.FuncDecl {
	foundCtors := map[string]*ast.FuncDecl{}
	for _, file := range p.Files {
		ast.Inspect(file, func(n ast.Node) bool {
			switch x := n.(type) {
			case *ast.FuncDecl:
				if x.Recv == nil {
					for _, t := range aboutTypes {
						if "New"+t == methodName(x) {
							foundCtors[t] = x
						}
					}
				}
			}
			return true
		})
	}
	return foundCtors
}

func astPrint(x interface{}) string {
	var b bytes.Buffer
	fset := token.NewFileSet()
	format.Node(&b, fset, x)
	return b.String()
}

func astPrintPkg(p *loader.PackageInfo) string {
	var b bytes.Buffer
	for _, file := range p.Files {
		b.WriteString(astPrint(file))
	}
	return b.String()
}

func methodName(m *ast.FuncDecl) string {
	return m.Name.Name
}
func methodReturnPointer(m *ast.FuncDecl) bool {
	if m.Type.Results != nil {
		for _, p := range m.Type.Results.List {
			if _, ok := p.Type.(*ast.Ident); !ok {
				return false
			}
		}
	}
	return true
}
func methodReturnTypes(m *ast.FuncDecl) []string {
	var ret []string
	if m.Type.Results != nil {
		for _, p := range m.Type.Results.List {
			if x, ok := p.Type.(*ast.Ident); ok {
				ret = append(ret, x.Name)
			} else if y, ok := p.Type.(*ast.StarExpr); ok {
				ret = append(ret, y.X.(*ast.Ident).Name)
			}
		}
	}
	return ret
}

var retVar int

func methodReturnVars(m *ast.FuncDecl) []string {
	var ret []string
	if m.Type.Results != nil {
		for range m.Type.Results.List {
			ret = append(ret, fmt.Sprintf("retVar%v", retVar))
			retVar++
		}
	}
	return ret
}
func methodParamNames(m *ast.FuncDecl) string {
	var ret []string
	for _, p := range m.Type.Params.List {
		ret = append(ret, p.Names[0].Name)
	}
	return strings.Join(ret, ", ")
}
func methodParams(m *ast.FuncDecl) string {
	var ret []string
	for _, p := range m.Type.Params.List {
		c := p.Names[0].Name + " " + p.Type.(*ast.Ident).Name
		ret = append(ret, c)
	}
	return strings.Join(ret, ", ")
}
func setReceiverName(m *ast.FuncDecl, name string) {
	m.Recv.List[0].Names[0].Name = name
}
func setReceiverPointer(m *ast.FuncDecl, pointer bool) {
	if y, ok := m.Recv.List[0].Type.(*ast.StarExpr); ok {
		if pointer == false {
			m.Recv.List[0].Type = y.X
		}
	} else if u, ok := m.Recv.List[0].Type.(*ast.Ident); ok {
		if pointer {
			m.Recv.List[0].Type = &ast.StarExpr{X: u}
		}
	}
}
func setReceiverTypeName(x *ast.FuncDecl, name string) {
	if y, ok := x.Recv.List[0].Type.(*ast.StarExpr); ok {
		y.X.(*ast.Ident).Name = name
	} else if u, ok := x.Recv.List[0].Type.(*ast.Ident); ok {
		u.Name = name
	}
}
func receiverName(m *ast.FuncDecl) string {
	return m.Recv.List[0].Names[0].Name
}
func receiverType(x *ast.FuncDecl) string {
	ret := ""
	if y, ok := x.Recv.List[0].Type.(*ast.StarExpr); ok {
		ret = y.X.(*ast.Ident).Name
	} else if u, ok := x.Recv.List[0].Type.(*ast.Ident); ok {
		ret = u.Name
	}
	return ret
}

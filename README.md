# channeler

[![travis Status](https://travis-ci.org//mh-cbon/channeler.svg?branch=master)](https://travis-ci.org//mh-cbon/channeler) [![Appveyor Status](https://ci.appveyor.com/api/projects/status//github/mh-cbon/channeler?branch=master&svg=true)](https://ci.appveyor.com/projects//mh-cbon/channeler) [![Go Report Card](https://goreportcard.com/badge/github.com/mh-cbon/channeler)](https://goreportcard.com/report/github.com/mh-cbon/channeler) [![GoDoc](https://godoc.org/github.com/mh-cbon/channeler?status.svg)](http://godoc.org/github.com/mh-cbon/channeler) [![MIT License](http://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)

Package channeler is a cli generator to generate channeled version of a type.


# TOC
- [Install](#install)
  - [Usage](#usage)
    - [$ channeler -help](#-channeler--help)
  - [Cli examples](#cli-examples)
- [API example](#api-example)
  - [> demo/lib.go](#-demolibgo)
  - [> demo/tomate_gen.go](#-demotomate_gengo)
- [Recipes](#recipes)
  - [Release the project](#release-the-project)
- [History](#history)

# Install
```sh
mkdir -p $GOPATH/src/github.com/mh-cbon/channeler
cd $GOPATH/src/github.com/mh-cbon/channeler
git clone https://github.com/mh-cbon/channeler.git .
glide install
go install
```

## Usage

#### $ channeler -help
```sh
channeler 0.0.0

Usage

	channeler [-p name] [out] [...types]

	out:   Output destination of the results, use '-' for stdout.
	types: A list of types such as src:dst.
	-p:    The name of the package output.
```

## Cli examples

```sh
# Create a channeled version os Tomate to MyTomate
channeler tomate_gen.go Tomate:MyTomate
```
# API example

Following example demonstates a program using it to generate a channeled version of a type.

#### > demo/lib.go
```go
package demo

import "fmt"

//go:generate channeler tomate_gen.go Tomate:MyTomate *Tomate:MyTomatePointer

// Tomate is a vegetable.
type Tomate struct {
	name string
}

// Hello world!
func (t *Tomate) Hello() { fmt.Println(" world!") }

// Good bye!
func (t Tomate) Good() { fmt.Println(" bye!") }

// Name it!
func (t Tomate) Name(it string) string { return fmt.Sprintf("Name:%v\n", it) }

// NewTomate isa contrstuctor
func NewTomate(n string) *Tomate {
	return &Tomate{
		name: n,
	}
}
```

Following code is the generated implementation of `Tomate` type.

#### > demo/tomate_gen.go
```go
package demo

// file generated by
// github.com.mh-cbon/channeler
// do not edit

// MyTomate is channeled.
type MyTomate struct {
	embed Tomate
	ops   chan func()
	stop  chan bool
}

// NewMyTomate constructs a chenneled version of Tomate
func NewMyTomate() *MyTomate {
	ret := &MyTomate{
		ops:  make(chan func()),
		stop: make(chan bool),
	}
	go ret.Start()
	return ret
}

// Start the main loop
func (t *MyTomate) Start() {
	for {
		select {
		case op := <-t.ops:
			op()
		case <-t.stop:
			return
		}
	}
}

// Stop the main loop
func (t *MyTomate) Stop() {
	t.stop <- true
}

// Hello is channeled
func (t *MyTomate) Hello() {
	t.ops <- func() {
		t.embed.Hello()
	}
}

// Good is channeled
func (t *MyTomate) Good() {
	t.ops <- func() {
		t.embed.Good()
	}
}

// Name is channeled
func (t *MyTomate) Name(it string) string {
	var retVar0 string
	t.ops <- func() {
		retVar0 = t.embed.Name(it)
	}
	return retVar0
}

// MyTomatePointer is channeled.
type MyTomatePointer struct {
	embed *Tomate
	ops   chan func()
	stop  chan bool
}

// NewMyTomatePointer constructs a chenneled version of *Tomate
func NewMyTomatePointer(n string) *MyTomatePointer {
	ret := &MyTomatePointer{
		ops:  make(chan func()),
		stop: make(chan bool),
	}
	ret.embed = NewTomate(n)
	go ret.Start()
	return ret
}

// Start the main loop
func (t *MyTomatePointer) Start() {
	for {
		select {
		case op := <-t.ops:
			op()
		case <-t.stop:
			return
		}
	}
}

// Stop the main loop
func (t *MyTomatePointer) Stop() {
	t.stop <- true
}

// Hello is channeled
func (t *MyTomatePointer) Hello() {
	t.ops <- func() {
		t.embed.Hello()
	}
}

// Good is channeled
func (t *MyTomatePointer) Good() {
	t.ops <- func() {
		t.embed.Good()
	}
}

// Name is channeled
func (t *MyTomatePointer) Name(it string) string {
	var retVar1 string
	t.ops <- func() {
		retVar1 = t.embed.Name(it)
	}
	return retVar1
}
```


# Recipes

#### Release the project

```sh
gump patch -d # check
gump patch # bump
```

# History

[CHANGELOG](CHANGELOG.md)

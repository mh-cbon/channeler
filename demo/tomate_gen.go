package demo

// file generated by
// github.com.mh-cbon/channeler
// do not edit

// MyTomate is channeled.
type MyTomate struct {
	embed Tomate
	ops   chan func()
	stop  chan bool
}

// NewMyTomate constructs a chenneled version of Tomate
func NewMyTomate() *MyTomate {
	ret := &MyTomate{
		ops:  make(chan func()),
		stop: make(chan bool),
	}
	go ret.Start()
	return ret
}

// Start the main loop
func (t *MyTomate) Start() {
	for {
		select {
		case op := <-t.ops:
			op()
		case <-t.stop:
			return
		}
	}
}

// Stop the main loop
func (t *MyTomate) Stop() {
	t.stop <- true
}

// Hello is channeled
func (t *MyTomate) Hello() {
	t.ops <- func() {
		t.embed.Hello()
	}
}

// Good is channeled
func (t *MyTomate) Good() {
	t.ops <- func() {
		t.embed.Good()
	}
}

// Name is channeled
func (t *MyTomate) Name(it string) string {
	var retVar0 string
	t.ops <- func() {
		retVar0 = t.embed.Name(it)
	}
	return retVar0
}

// MyTomatePointer is channeled.
type MyTomatePointer struct {
	embed *Tomate
	ops   chan func()
	stop  chan bool
}

// NewMyTomatePointer constructs a chenneled version of *Tomate
func NewMyTomatePointer(n string) *MyTomatePointer {
	ret := &MyTomatePointer{
		ops:  make(chan func()),
		stop: make(chan bool),
	}
	ret.embed = NewTomate(n)
	go ret.Start()
	return ret
}

// Start the main loop
func (t *MyTomatePointer) Start() {
	for {
		select {
		case op := <-t.ops:
			op()
		case <-t.stop:
			return
		}
	}
}

// Stop the main loop
func (t *MyTomatePointer) Stop() {
	t.stop <- true
}

// Hello is channeled
func (t *MyTomatePointer) Hello() {
	t.ops <- func() {
		t.embed.Hello()
	}
}

// Good is channeled
func (t *MyTomatePointer) Good() {
	t.ops <- func() {
		t.embed.Good()
	}
}

// Name is channeled
func (t *MyTomatePointer) Name(it string) string {
	var retVar1 string
	t.ops <- func() {
		retVar1 = t.embed.Name(it)
	}
	return retVar1
}
